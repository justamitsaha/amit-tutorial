{
    "content": {
        "pageHeader": "Method Reference",
        "topicList": [
            {
                "topicHeader": "Method Reference",
                "topicMsgList": [
                    {
                        "topicText": "Method reference is used to refer method of functional interface. It is compact and easy form of lambda expression. When we simply pass the parameters of Lambda expression to functional interface implementation we can instead use Method reference instead of Lambda which looks much cleaner. You can pretend the compiler turns your method references into lambdas for you. There are four formats for method references.",
                        "cardCodeList": [
                            {
                                "code": "TestClass obj= () -&gt; System.out.println(&quot;Lambda&quot;);<br />obj.testMethod();",
                                "textDesc": "Lambda implementation"
                            },
                            {
                                "code": "TestClass obj= System.out::println;<br /> obj.testMethod();",
                                "textDesc": "Method Reference implementation"
                            }
                        ]
                    },
                    {
                        "topicText": "With out Lambda we have to go for either Initializing the interface or Inner class implementation. But both have draw backs that they create extra class files which can bloat the footprint of application",
                        "cardCodeList": [
                            {
                                "code": "public class Test {<br /> &nbsp;&nbsp;public static void main(String[] args) {<br /> &nbsp;&nbsp; &nbsp;ShoutImpl sh = new ShoutImpl();<br /> &nbsp;&nbsp; &nbsp;sh.shout();<br /> &nbsp;&nbsp;}<br /> }<br /> <br /> @FunctionalInterface<br /> interface Shout { void shout(); }<br /> <br /> class ShoutImpl implements Shout {<br /> &nbsp;&nbsp;@Override<br /> &nbsp;&nbsp;public void shout() { System.out.println(&quot;Interface&quot;); &nbsp;}<br /> }",
                                "textDesc": "Implementing the interface."
                            },
                            {
                                "img": "../../../assets/json/java/tutorials/lambdas/InterfaceImpl.png",
                                "textDesc": "Implementing the interface extra class created."
                            }
                        ]
                    },
                    {
                        "topicText": "In Inner class we are not creating implementation but the inner class still creates Anonymous class.",
                        "cardCodeList": [
                            {
                                "code": "public class Test {<br /> &nbsp;&nbsp;public static void main(String[] args) {<br /> &nbsp;&nbsp; &nbsp;Shout shoutInnerClass = new Shout() {<br /> &nbsp;&nbsp; &nbsp; &nbsp;public void shout() { System.out.println(&quot;Inner Class&quot;); }<br /> &nbsp;&nbsp; &nbsp;};<br /> &nbsp;&nbsp; &nbsp;shoutInnerClass.shout();<br /> &nbsp;&nbsp;}<br /> }<br /> <br /> @FunctionalInterface<br /> interface Shout { void shout(); }",
                                "textDesc": " Inner class implementation"
                            },
                            {
                                "img": "../../../assets/json/java/tutorials/lambdas/InnerClass.png",
                                "textDesc": " Anonymous class created adding overhead to application."
                            }
                        ]
                    },
                    {
                        "topicText": " A Lambda expression always needs a functional interface method to execute"
                    },
                    {
                        "topicText": " It is a good practice to keep one or two line of code in Lambda expression."
                    }
                ]
            }
        ]
    }
}